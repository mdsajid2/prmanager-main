import { AIAnalysis } from "../schemas";

export function buildMarkdownArtifacts(
  ai: AIAnalysis,
  heuristicHotspots: string[]
): {
  pr_description: string;
  review_comment: string;
} {
  const prDescription = ai.suggested_pr_description;

  const reviewComment = buildReviewComment(ai, heuristicHotspots);

  return {
    pr_description: prDescription,
    review_comment: reviewComment,
  };
}

function buildReviewComment(
  ai: AIAnalysis,
  heuristicHotspots: string[]
): string {
  const {
    risk,
    summary,
    reviewer_checklist,
    questions_for_author,
    missing_tests,
    generated_test_plan,
    commands_to_run,
  } = ai;

  let markdown = `# PR Manager Review Package [Risk: ${risk.level} ${risk.score}/100]\n\n`;

  // Summary
  markdown += `## Summary\n`;
  summary.forEach((item) => {
    markdown += `- ${item}\n`;
  });
  markdown += "\n";

  // Risk Assessment
  markdown += `## Why it's risky\n`;

  // Combine heuristic and AI reasons
  const allReasons = [...new Set([...risk.reasons, ...heuristicHotspots])];
  allReasons.forEach((reason) => {
    markdown += `- ${reason}\n`;
  });

  if (risk.hotspots.length > 0) {
    markdown += "\n### Hotspots\n";
    risk.hotspots.forEach((hotspot) => {
      markdown += `- **${hotspot.file}**: ${hotspot.notes}\n`;
    });
  }
  markdown += "\n";

  // Reviewer Checklist
  markdown += `## Reviewer Checklist\n\n`;

  if (reviewer_checklist.blocking_items.length > 0) {
    markdown += `### Blocking Items\n`;
    reviewer_checklist.blocking_items.forEach((item) => {
      markdown += `- [ ] ${item}\n`;
    });
    markdown += "\n";
  }

  if (reviewer_checklist.non_blocking_items.length > 0) {
    markdown += `### Non-blocking Items\n`;
    reviewer_checklist.non_blocking_items.forEach((item) => {
      markdown += `- [ ] ${item}\n`;
    });
    markdown += "\n";
  }

  // Questions for Author
  if (questions_for_author.length > 0) {
    markdown += `## Questions for Author\n`;
    questions_for_author.forEach((question) => {
      markdown += `- ${question}\n`;
    });
    markdown += "\n";
  }

  // Missing Tests
  if (missing_tests.length > 0) {
    markdown += `## Missing Tests\n`;
    missing_tests.forEach((test) => {
      markdown += `- ${test}\n`;
    });
    markdown += "\n";
  }

  // Test Plan
  markdown += `## Test Plan\n\n`;

  if (generated_test_plan.unit.length > 0) {
    markdown += `### Unit Tests\n`;
    generated_test_plan.unit.forEach((test) => {
      markdown += `- ${test}\n`;
    });
    markdown += "\n";
  }

  if (generated_test_plan.integration.length > 0) {
    markdown += `### Integration Tests\n`;
    generated_test_plan.integration.forEach((test) => {
      markdown += `- ${test}\n`;
    });
    markdown += "\n";
  }

  if (generated_test_plan.manual.length > 0) {
    markdown += `### Manual Testing\n`;
    generated_test_plan.manual.forEach((test) => {
      markdown += `- ${test}\n`;
    });
    markdown += "\n";
  }

  // Commands to Run
  if (commands_to_run.length > 0) {
    markdown += `## Commands to Run\n\n`;
    markdown += "```bash\n";
    commands_to_run.forEach((command) => {
      markdown += `${command}\n`;
    });
    markdown += "```\n\n";
  }

  // Footer
  markdown += `---\n*Generated by PR Manager*`;

  return markdown;
}

export function redactSecrets(text: string): string {
  // Basic secret redaction patterns
  const patterns = [
    // API keys
    /([a-zA-Z0-9_-]*[aA][pP][iI][_-]?[kK][eE][yY][_-]?[a-zA-Z0-9_-]*\s*[:=]\s*)['"]*([a-zA-Z0-9_-]{20,})['"]*$/gm,
    // Tokens
    /([a-zA-Z0-9_-]*[tT][oO][kK][eE][nN][_-]?[a-zA-Z0-9_-]*\s*[:=]\s*)['"]*([a-zA-Z0-9_-]{20,})['"]*$/gm,
    // Passwords
    /([a-zA-Z0-9_-]*[pP][aA][sS][sS][wW][oO][rR][dD][_-]?[a-zA-Z0-9_-]*\s*[:=]\s*)['"]*([a-zA-Z0-9_!@#$%^&*()-]{8,})['"]*$/gm,
    // Generic secrets
    /([a-zA-Z0-9_-]*[sS][eE][cC][rR][eE][tT][_-]?[a-zA-Z0-9_-]*\s*[:=]\s*)['"]*([a-zA-Z0-9_-]{16,})['"]*$/gm,
  ];

  let redacted = text;
  patterns.forEach((pattern) => {
    redacted = redacted.replace(pattern, "$1[REDACTED]");
  });

  return redacted;
}
